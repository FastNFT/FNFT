<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FNFT: Data types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FNFT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle"><div class="title">Data types</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Data types:</div>
<div class="dyncontent">
<div class="center"><img src="group__data__types.png" border="0" usemap="#agroup____data____types" alt=""/></div>
<map name="agroup____data____types" id="agroup____data____types">
<area shape="rect" title=" " alt="" coords="5,82,98,110"/>
<area shape="rect" href="group__fnft.html" title=" " alt="" coords="310,39,473,84"/>
<area shape="rect" href="group__fnft__inverse.html" title=" " alt="" coords="309,108,474,153"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfnft__kdvv__opts__t.html">fnft_kdvv_opts_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores additional options for the routine <a class="el" href="group__fnft.html#ga944e84c5d6d91142b8e062a3aa2e497d">fnft_kdvv</a>.  <a href="structfnft__kdvv__opts__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfnft__manakovv__opts__t.html">fnft_manakovv_opts_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores additional options for the routine <a class="el" href="group__fnft.html#ga2dd02971674ab93cdb07ea3620ece96d">fnft_manakovv</a>.  <a href="structfnft__manakovv__opts__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfnft__nsep__opts__t.html">fnft_nsep_opts_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores additional options for the routine <a class="el" href="group__fnft.html#ga54373ffc2bf1f108dc11dd8ba7cdc405">fnft_nsep</a>.  <a href="structfnft__nsep__opts__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfnft__nsev__opts__t.html">fnft_nsev_opts_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores additional options for the routine <a class="el" href="group__fnft.html#gaa5d8a57faa42b4a86797ed3c829e7c0f">fnft_nsev</a>.  <a href="structfnft__nsev__opts__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfnft__nsev__inverse__opts__t.html">fnft_nsev_inverse_opts_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores additional options for the routine <a class="el" href="group__fnft__inverse.html#ga96e7f068533c27369ce71f94b4c31bd1">fnft_nsev_inverse</a>.  <a href="structfnft__nsev__inverse__opts__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga10835ef19579608a235d4cee906b286c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#ga10835ef19579608a235d4cee906b286c">fnft_kdv_discretization_t</a> { <br />
&#160;&#160;<b>fnft_kdv_discretization_2SPLIT2_MODAL_VANILLA</b>
, <b>fnft_kdv_discretization_BO_VANILLA</b>
, <b>fnft_kdv_discretization_2SPLIT1A_VANILLA</b>
, <b>fnft_kdv_discretization_2SPLIT1B_VANILLA</b>
, <br />
&#160;&#160;<b>fnft_kdv_discretization_2SPLIT2A_VANILLA</b>
, <b>fnft_kdv_discretization_2SPLIT2B_VANILLA</b>
, <b>fnft_kdv_discretization_2SPLIT2S_VANILLA</b>
, <b>fnft_kdv_discretization_2SPLIT3A_VANILLA</b>
, <br />
&#160;&#160;<b>fnft_kdv_discretization_2SPLIT3B_VANILLA</b>
, <b>fnft_kdv_discretization_2SPLIT3S_VANILLA</b>
, <b>fnft_kdv_discretization_2SPLIT4A_VANILLA</b>
, <b>fnft_kdv_discretization_2SPLIT4B_VANILLA</b>
, <br />
&#160;&#160;<b>fnft_kdv_discretization_2SPLIT5A_VANILLA</b>
, <b>fnft_kdv_discretization_2SPLIT5B_VANILLA</b>
, <b>fnft_kdv_discretization_2SPLIT6A_VANILLA</b>
, <b>fnft_kdv_discretization_2SPLIT6B_VANILLA</b>
, <br />
&#160;&#160;<b>fnft_kdv_discretization_2SPLIT7A_VANILLA</b>
, <b>fnft_kdv_discretization_2SPLIT7B_VANILLA</b>
, <b>fnft_kdv_discretization_2SPLIT8A_VANILLA</b>
, <b>fnft_kdv_discretization_2SPLIT8B_VANILLA</b>
, <br />
&#160;&#160;<b>fnft_kdv_discretization_4SPLIT4A_VANILLA</b>
, <b>fnft_kdv_discretization_4SPLIT4B_VANILLA</b>
, <b>fnft_kdv_discretization_CF4_2_VANILLA</b>
, <b>fnft_kdv_discretization_CF4_3_VANILLA</b>
, <br />
&#160;&#160;<b>fnft_kdv_discretization_CF5_3_VANILLA</b>
, <b>fnft_kdv_discretization_CF6_4_VANILLA</b>
, <b>fnft_kdv_discretization_ES4_VANILLA</b>
, <b>fnft_kdv_discretization_TES4_VANILLA</b>
, <br />
&#160;&#160;<b>fnft_kdv_discretization_2SPLIT2_MODAL</b>
, <b>fnft_kdv_discretization_BO</b>
, <b>fnft_kdv_discretization_2SPLIT1A</b>
, <b>fnft_kdv_discretization_2SPLIT1B</b>
, <br />
&#160;&#160;<b>fnft_kdv_discretization_2SPLIT2A</b>
, <b>fnft_kdv_discretization_2SPLIT2B</b>
, <b>fnft_kdv_discretization_2SPLIT2S</b>
, <b>fnft_kdv_discretization_2SPLIT3A</b>
, <br />
&#160;&#160;<b>fnft_kdv_discretization_2SPLIT3B</b>
, <b>fnft_kdv_discretization_2SPLIT3S</b>
, <b>fnft_kdv_discretization_2SPLIT4A</b>
, <b>fnft_kdv_discretization_2SPLIT4B</b>
, <br />
&#160;&#160;<b>fnft_kdv_discretization_2SPLIT5A</b>
, <b>fnft_kdv_discretization_2SPLIT5B</b>
, <b>fnft_kdv_discretization_2SPLIT6A</b>
, <b>fnft_kdv_discretization_2SPLIT6B</b>
, <br />
&#160;&#160;<b>fnft_kdv_discretization_2SPLIT7A</b>
, <b>fnft_kdv_discretization_2SPLIT7B</b>
, <b>fnft_kdv_discretization_2SPLIT8A</b>
, <b>fnft_kdv_discretization_2SPLIT8B</b>
, <br />
&#160;&#160;<b>fnft_kdv_discretization_4SPLIT4A</b>
, <b>fnft_kdv_discretization_4SPLIT4B</b>
, <b>fnft_kdv_discretization_CF4_2</b>
, <b>fnft_kdv_discretization_CF4_3</b>
, <br />
&#160;&#160;<b>fnft_kdv_discretization_CF5_3</b>
, <b>fnft_kdv_discretization_CF6_4</b>
, <b>fnft_kdv_discretization_ES4</b>
, <b>fnft_kdv_discretization_TES4</b>
<br />
 }</td></tr>
<tr class="memdesc:ga10835ef19579608a235d4cee906b286c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum that specifies discretizations and methods used to compute nonlinear Fourier transforms for the Korteweg-de Vries Equation.  <a href="group__data__types.html#ga10835ef19579608a235d4cee906b286c">More...</a><br /></td></tr>
<tr class="separator:ga10835ef19579608a235d4cee906b286c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7165be78ff704ce76877adb43dfa87cc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#ga7165be78ff704ce76877adb43dfa87cc">fnft_kdvv_bsloc_t</a> { <b>fnft_kdvv_bsloc_NEWTON</b>
, <b>fnft_kdvv_bsloc_GRIDSEARCH_AND_REFINE</b>
 }</td></tr>
<tr class="separator:ga7165be78ff704ce76877adb43dfa87cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee315490ec1fae3f8eed2312f7b4adad"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#gaee315490ec1fae3f8eed2312f7b4adad">fnft_kdvv_dstype_t</a> { <b>fnft_kdvv_dstype_NORMING_CONSTANTS</b>
, <b>fnft_kdvv_dstype_RESIDUES</b>
, <b>fnft_kdvv_dstype_BOTH</b>
 }</td></tr>
<tr class="separator:gaee315490ec1fae3f8eed2312f7b4adad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96100b1d82129d86a29b0b2e77ab3c80"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#ga96100b1d82129d86a29b0b2e77ab3c80">fnft_kdvv_cstype_t</a> { <b>fnft_kdvv_cstype_REFLECTION_COEFFICIENT</b>
, <b>fnft_kdvv_cstype_AB</b>
, <b>fnft_kdvv_cstype_BOTH</b>
 }</td></tr>
<tr class="separator:ga96100b1d82129d86a29b0b2e77ab3c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedc0f9c54a7e031f4c34ce4fbe66333e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#gaedc0f9c54a7e031f4c34ce4fbe66333e">fnft_manakov_discretization_t</a> { <br />
&#160;&#160;<b>fnft_manakov_discretization_2SPLIT3A</b>
, <b>fnft_manakov_discretization_2SPLIT3B</b>
, <b>fnft_manakov_discretization_2SPLIT4A</b>
, <b>fnft_manakov_discretization_2SPLIT4B</b>
, <br />
&#160;&#160;<b>fnft_manakov_discretization_2SPLIT6B</b>
, <b>fnft_manakov_discretization_4SPLIT4A</b>
, <b>fnft_manakov_discretization_4SPLIT4B</b>
, <b>fnft_manakov_discretization_4SPLIT6B</b>
, <br />
&#160;&#160;<b>fnft_manakov_discretization_FTES4_4A</b>
, <b>fnft_manakov_discretization_FTES4_4B</b>
, <b>fnft_manakov_discretization_FTES4_suzuki</b>
, <b>fnft_manakov_discretization_CF4_2</b>
, <br />
&#160;&#160;<b>fnft_manakov_discretization_BO</b>
<br />
 }</td></tr>
<tr class="memdesc:gaedc0f9c54a7e031f4c34ce4fbe66333e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum that specifies discretizations and methods used to compute nonlinear Fourier transforms for the Manakov Equation.  <a href="group__data__types.html#gaedc0f9c54a7e031f4c34ce4fbe66333e">More...</a><br /></td></tr>
<tr class="separator:gaedc0f9c54a7e031f4c34ce4fbe66333e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0332f0ca69331fdc6fb1c3f8a3985a9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#gac0332f0ca69331fdc6fb1c3f8a3985a9">fnft_manakovv_bsfilt_t</a> { <b>fnft_manakovv_bsfilt_NONE</b>
, <b>fnft_manakovv_bsfilt_BASIC</b>
, <b>fnft_manakovv_bsfilt_FULL</b>
 }</td></tr>
<tr class="separator:gac0332f0ca69331fdc6fb1c3f8a3985a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga621a1e5cb0ae2393088aed46e9ea3abc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#ga621a1e5cb0ae2393088aed46e9ea3abc">fnft_manakovv_bsloc_t</a> { <b>fnft_manakovv_bsloc_FAST_EIGENVALUE</b>
, <b>fnft_manakovv_bsloc_NEWTON</b>
, <b>fnft_manakovv_bsloc_SUBSAMPLE_AND_REFINE</b>
 }</td></tr>
<tr class="separator:ga621a1e5cb0ae2393088aed46e9ea3abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cfffa33b6143046ac4a6f80648b61a6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#ga6cfffa33b6143046ac4a6f80648b61a6">fnft_manakovv_dstype_t</a> { <b>fnft_manakovv_dstype_NORMING_CONSTANTS</b>
, <b>fnft_manakovv_dstype_RESIDUES</b>
, <b>fnft_manakovv_dstype_BOTH</b>
 }</td></tr>
<tr class="separator:ga6cfffa33b6143046ac4a6f80648b61a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf98843a45007d9bb52e4a027e7324d38"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#gaf98843a45007d9bb52e4a027e7324d38">fnft_manakovv_cstype_t</a> { <b>fnft_manakovv_cstype_REFLECTION_COEFFICIENT</b>
, <b>fnft_manakovv_cstype_AB</b>
, <b>fnft_manakovv_cstype_BOTH</b>
 }</td></tr>
<tr class="separator:gaf98843a45007d9bb52e4a027e7324d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7910f5e26ab68217ed7d6565c539d1b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#gac7910f5e26ab68217ed7d6565c539d1b">fnft_nse_discretization_t</a> { <br />
&#160;&#160;<b>fnft_nse_discretization_2SPLIT2_MODAL</b>
, <b>fnft_nse_discretization_BO</b>
, <b>fnft_nse_discretization_2SPLIT1A</b>
, <b>fnft_nse_discretization_2SPLIT1B</b>
, <br />
&#160;&#160;<b>fnft_nse_discretization_2SPLIT2A</b>
, <b>fnft_nse_discretization_2SPLIT2B</b>
, <b>fnft_nse_discretization_2SPLIT2S</b>
, <b>fnft_nse_discretization_2SPLIT3A</b>
, <br />
&#160;&#160;<b>fnft_nse_discretization_2SPLIT3B</b>
, <b>fnft_nse_discretization_2SPLIT3S</b>
, <b>fnft_nse_discretization_2SPLIT4A</b>
, <b>fnft_nse_discretization_2SPLIT4B</b>
, <br />
&#160;&#160;<b>fnft_nse_discretization_2SPLIT5A</b>
, <b>fnft_nse_discretization_2SPLIT5B</b>
, <b>fnft_nse_discretization_2SPLIT6A</b>
, <b>fnft_nse_discretization_2SPLIT6B</b>
, <br />
&#160;&#160;<b>fnft_nse_discretization_2SPLIT7A</b>
, <b>fnft_nse_discretization_2SPLIT7B</b>
, <b>fnft_nse_discretization_2SPLIT8A</b>
, <b>fnft_nse_discretization_2SPLIT8B</b>
, <br />
&#160;&#160;<b>fnft_nse_discretization_4SPLIT4A</b>
, <b>fnft_nse_discretization_4SPLIT4B</b>
, <b>fnft_nse_discretization_CF4_2</b>
, <b>fnft_nse_discretization_CF4_3</b>
, <br />
&#160;&#160;<b>fnft_nse_discretization_CF5_3</b>
, <b>fnft_nse_discretization_CF6_4</b>
, <b>fnft_nse_discretization_ES4</b>
, <b>fnft_nse_discretization_TES4</b>
<br />
 }</td></tr>
<tr class="memdesc:gac7910f5e26ab68217ed7d6565c539d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum that specifies discretizations and methods used to compute nonlinear Fourier transforms for the Nonlinear Schroedinger Equation.  <a href="group__data__types.html#gac7910f5e26ab68217ed7d6565c539d1b">More...</a><br /></td></tr>
<tr class="separator:gac7910f5e26ab68217ed7d6565c539d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga844c6b6fe944797f846f896a14734eeb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#ga844c6b6fe944797f846f896a14734eeb">fnft_nsep_loc_t</a> { <b>fnft_nsep_loc_SUBSAMPLE_AND_REFINE</b>
, <b>fnft_nsep_loc_NEWTON</b>
, <b>fnft_nsep_loc_GRIDSEARCH</b>
, <b>fnft_nsep_loc_MIXED</b>
 }</td></tr>
<tr class="separator:ga844c6b6fe944797f846f896a14734eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648f442b682061a897c83f78de962dd1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#ga648f442b682061a897c83f78de962dd1">fnft_nsep_filt_t</a> { <b>fnft_nsep_filt_NONE</b>
, <b>fnft_nsep_filt_MANUAL</b>
, <b>fnft_nsep_filt_AUTO</b>
 }</td></tr>
<tr class="separator:ga648f442b682061a897c83f78de962dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab42605e09c16a68525a77b09ef10a9e5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#gab42605e09c16a68525a77b09ef10a9e5">fnft_nsev_bsfilt_t</a> { <b>fnft_nsev_bsfilt_NONE</b>
, <b>fnft_nsev_bsfilt_BASIC</b>
, <b>fnft_nsev_bsfilt_FULL</b>
, <b>fnft_nsev_bsfilt_MANUAL</b>
 }</td></tr>
<tr class="separator:gab42605e09c16a68525a77b09ef10a9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ebbf0382d833e9fb91af6c5a5675cee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#ga9ebbf0382d833e9fb91af6c5a5675cee">fnft_nsev_bsloc_t</a> { <b>fnft_nsev_bsloc_FAST_EIGENVALUE</b>
, <b>fnft_nsev_bsloc_NEWTON</b>
, <b>fnft_nsev_bsloc_SUBSAMPLE_AND_REFINE</b>
 }</td></tr>
<tr class="separator:ga9ebbf0382d833e9fb91af6c5a5675cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3d9c4fed6adc1ccf08e907d295cc41b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#gaf3d9c4fed6adc1ccf08e907d295cc41b">fnft_nsev_dstype_t</a> { <b>fnft_nsev_dstype_NORMING_CONSTANTS</b>
, <b>fnft_nsev_dstype_RESIDUES</b>
, <b>fnft_nsev_dstype_BOTH</b>
 }</td></tr>
<tr class="separator:gaf3d9c4fed6adc1ccf08e907d295cc41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e14d44f071521723b416a1d44433b1e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#ga6e14d44f071521723b416a1d44433b1e">fnft_nsev_cstype_t</a> { <b>fnft_nsev_cstype_REFLECTION_COEFFICIENT</b>
, <b>fnft_nsev_cstype_AB</b>
, <b>fnft_nsev_cstype_BOTH</b>
 }</td></tr>
<tr class="separator:ga6e14d44f071521723b416a1d44433b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35417fabb6b4268a7c1c728ca57f16ff"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#ga35417fabb6b4268a7c1c728ca57f16ff">fnft_nsev_inverse_cstype_t</a> { <b>fnft_nsev_inverse_cstype_REFLECTION_COEFFICIENT</b>
, <b>fnft_nsev_inverse_cstype_B_OF_XI</b>
, <b>fnft_nsev_inverse_cstype_B_OF_TAU</b>
 }</td></tr>
<tr class="separator:ga35417fabb6b4268a7c1c728ca57f16ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a129a7c3e6a5da2690747dc228b76cf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#ga6a129a7c3e6a5da2690747dc228b76cf">fnft_nsev_inverse_dstype_t</a> { <b>fnft_nsev_inverse_dstype_NORMING_CONSTANTS</b>
, <b>fnft_nsev_inverse_dstype_RESIDUES</b>
 }</td></tr>
<tr class="separator:ga6a129a7c3e6a5da2690747dc228b76cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e8a23ea9190fbc59bc7d52832e5cc11"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#ga2e8a23ea9190fbc59bc7d52832e5cc11">fnft_nsev_inverse_csmethod_t</a> { <b>fnft_nsev_inverse_csmethod_DEFAULT</b>
, <b>fnft_nsev_inverse_csmethod_TFMATRIX_CONTAINS_REFL_COEFF</b>
, <b>fnft_nsev_inverse_csmethod_TFMATRIX_CONTAINS_AB_FROM_ITER</b>
, <b>fnft_nsev_inverse_csmethod_USE_SEED_POTENTIAL_INSTEAD</b>
 }</td></tr>
<tr class="separator:ga2e8a23ea9190fbc59bc7d52832e5cc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7c714776883a98e3df072d395aa2dc1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#gaf7c714776883a98e3df072d395aa2dc1">fnft__akns_discretization_t</a> { <br />
&#160;&#160;<b>fnft__akns_discretization_2SPLIT2_MODAL</b>
, <b>fnft__akns_discretization_2SPLIT1A</b>
, <b>fnft__akns_discretization_2SPLIT1B</b>
, <b>fnft__akns_discretization_2SPLIT2A</b>
, <br />
&#160;&#160;<b>fnft__akns_discretization_2SPLIT2B</b>
, <b>fnft__akns_discretization_2SPLIT2S</b>
, <b>fnft__akns_discretization_2SPLIT3A</b>
, <b>fnft__akns_discretization_2SPLIT3B</b>
, <br />
&#160;&#160;<b>fnft__akns_discretization_2SPLIT3S</b>
, <b>fnft__akns_discretization_2SPLIT4A</b>
, <b>fnft__akns_discretization_2SPLIT4B</b>
, <b>fnft__akns_discretization_2SPLIT5A</b>
, <br />
&#160;&#160;<b>fnft__akns_discretization_2SPLIT5B</b>
, <b>fnft__akns_discretization_2SPLIT6A</b>
, <b>fnft__akns_discretization_2SPLIT6B</b>
, <b>fnft__akns_discretization_2SPLIT7A</b>
, <br />
&#160;&#160;<b>fnft__akns_discretization_2SPLIT7B</b>
, <b>fnft__akns_discretization_2SPLIT8A</b>
, <b>fnft__akns_discretization_2SPLIT8B</b>
, <b>fnft__akns_discretization_BO</b>
, <br />
&#160;&#160;<b>fnft__akns_discretization_4SPLIT4A</b>
, <b>fnft__akns_discretization_4SPLIT4B</b>
, <b>fnft__akns_discretization_CF4_2</b>
, <b>fnft__akns_discretization_CF4_3</b>
, <br />
&#160;&#160;<b>fnft__akns_discretization_CF5_3</b>
, <b>fnft__akns_discretization_CF6_4</b>
, <b>fnft__akns_discretization_ES4</b>
, <b>fnft__akns_discretization_TES4</b>
, <br />
&#160;&#160;<b>fnft__akns_discretization_FTES4_4A</b>
, <b>fnft__akns_discretization_FTES4_4B</b>
, <b>fnft__akns_discretization_4SPLIT6B</b>
<br />
 }</td></tr>
<tr class="memdesc:gaf7c714776883a98e3df072d395aa2dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum that specifies discretizations used to compute nonlinear Fourier transforms of systems that fit the AKNS model.  <a href="group__data__types.html#gaf7c714776883a98e3df072d395aa2dc1">More...</a><br /></td></tr>
<tr class="separator:gaf7c714776883a98e3df072d395aa2dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98007ff9d80f79fe3a33663502c256de"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__types.html#ga98007ff9d80f79fe3a33663502c256de">fnft__akns_pde_t</a> { <b>fnft__akns_pde_KdV</b>
, <b>fnft__akns_pde_NSE</b>
 }</td></tr>
<tr class="memdesc:ga98007ff9d80f79fe3a33663502c256de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum that specifies partial differential equations for which the nonlinear Fourier transform can be calculated with the AKNS framework. M. J. Ablowitz, D. J. Kaup, A. C. Newell, and H. Segur, “The inverse scattering transform - Fourier analysis for nonlinear problems,” Studies in Applied Mathematics, vol. 53, pp. 249–315, 12 1974. <code>fnft__akns_pde_KdV</code> &ndash; Korteweg-de Vries equation:  <a href="group__data__types.html#ga98007ff9d80f79fe3a33663502c256de">More...</a><br /></td></tr>
<tr class="separator:ga98007ff9d80f79fe3a33663502c256de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaf7c714776883a98e3df072d395aa2dc1" name="gaf7c714776883a98e3df072d395aa2dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7c714776883a98e3df072d395aa2dc1">&#9670;&#160;</a></span>fnft__akns_discretization_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#gaf7c714776883a98e3df072d395aa2dc1">fnft__akns_discretization_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum that specifies discretizations used to compute nonlinear Fourier transforms of systems that fit the AKNS model. </p>
<p>Each discretization is always related to a particular numerical method and some are additionally related to a splitting-scheme.<br  />
 <code>fnft__akns_discretization_BO</code> has been taken from Boffetta and Osborne, <a href="https://doi.org/10.1016/0021-9991(92)90370-E">&quot; Computation of the direct scattering transform for the nonlinear Schroedinger equation,&quot;</a> J. Comput. Phys. 102(2), 1992.<br  />
 <code>fnft__akns_discretization_CFx_y</code> are from Chimmalgi, Prins and Wahls, <a href="https://doi.org/10.1109/ACCESS.2019.2945480">&quot; Fast Nonlinear Fourier Transform Algorithms Using Higher Order Exponential Integrators,&quot;</a> IEEE Access 7, 2019. They are higher-order commutator-free exponential integrators with <code>x</code> denoting the order of the method and <code>y</code> the number of matrix exponentials required per signal sample. <br  />
 <code>fnft__akns_discretization_ES4</code> and <code>fnft__akns_discretization_TES4</code> are fourth-order methods from Medvedev, Vaseva, Chekhovskoy and Fedoruk <a href="https://doi.org/10.1364/OE.377140">&quot; Exponential fourth order schemes for direct Zakharov-Shabat problem,&quot;</a> Optics Express, vol. 28, pp. 20&ndash;39, 2020.<br  />
 All above discretizations are supported by <a class="el" href="fnft____akns__scatter_8h.html">fnft__akns_scatter.h</a>.<br  />
 The exponential spliting schemes, defined in Prins and Wahls, <a href="https://doi.org/10.1109/ICASSP.2018.8461708">&quot; Higher order exponential splittings for the fast non-linear Fourier transform of the KdV equation,&quot; </a>Proc. ICASSP 2018, pp. 4524-4528 have been applied to the second-order method by Boffetta and Osborne and to the fourth-order CF4_2 method to obtain other discretizations.<br  />
 The <code>fnft__akns_discretization_2SPLIT2_MODAL</code> discretization is an exception. It is the normalized Ablowitz-Ladik discretization Eq. 25 in Wahls and Vaibhav<a href="https://arxiv.org/pdf/1607.01305v2.pdf">&quot; Fast Inverse Nonlinear Fourier Transforms for Continuous Spectra of Zakharov-Shabat Type ,&quot;</a> Unpublished.<br  />
 All other discretizations have the notation <code>xSPLITyz</code>, where <code>x</code> is the error order of the base numerical method and <code>y</code> is the order of accuracy of splitting scheme. <code>z</code> is type of splitting and can be <code>A</code>, <code>B</code> or <code>S</code>, with <code>A</code> standing for schemes implemented as defined in Prins and Wahls, <a href="https://doi.org/10.1109/ICASSP.2018.8461708">&quot; Higher order exponential splittings for the fast non-linear Fourier transform of the KdV equation,&quot; </a>Proc. ICASSP 2018, pp. 4524-4528. <code>B</code> type of splitting are the same as <code>A</code> with the positions of the two terms in the splitting interchanged. <code>S</code> is for splittings not mentioned in above reference.<br  />
 <code>-2S</code> is from G. Strang,<a href="https://link.springer.com/content/pdf/10.1007/BF00281235.pdf">&quot; Accurate partial difference methods I: Linear Cauchy problems,&quot;</a> in Archive for Rational Mechanics and Analysis, 12(1), 392-402, Jan 1963. It is also known as the Symmetric Weighted Sequential Splitting scheme (SWSS).<br  />
<code>-3S</code> is from Eq. 14.4 in S. Brustein and A. Mirin,<a href="https://doi.org/10.1016/0021-9991(70)90080-X">&quot; Third Order Difference Methods for Hyperbolic Equations,&quot;</a> J. Comput. Phys., 5, 547-571, 1970.<br  />
 In general, discretizations with a lower degree are faster, while those with a highter order of accuracy are more accurate. Therefore, the best choice is normally among <code>-2A</code>, <code>-2B</code>, <code>-2S</code> <code>-4B</code>, <code>-6B</code> and <code>-8B</code>. The choice between these is a trade-off between speed and accuracy.</p>
<p><code>fnft__akns_discretization_2SPLIT1A</code>: Order of base method = 2, Degree = 1, Order of accuracy of splitting-scheme = 1<br  />
 <code>fnft__akns_discretization_2SPLIT1B</code>: Order of base method = 2, Degree = 1, Order of accuracy of splitting-scheme = 1<br  />
 <code>fnft__akns_discretization_2SPLIT2A</code>: Order of base method = 2, Degree = 1, Order of accuracy of splitting-scheme = 2<br  />
 <code>fnft__akns_discretization_2SPLIT2B</code>: Order of base method = 2, Degree = 1, Order of accuracy of splitting-scheme = 2<br  />
 <code>fnft__akns_discretization_2SPLIT2S</code>: Order of base method = 2, Degree = 1, Order of accuracy of splitting-scheme = 2<br  />
 <code>fnft__akns_discretization_2SPLIT2_MODAL</code>: Order of base method = 2, Degree = 1, Order of accuracy of splitting-scheme = 2<br  />
 <code>fnft__akns_discretization_2SPLIT3A</code>: Order of base method = 2, Degree = 3, Order of accuracy of splitting-scheme = 3<br  />
 <code>fnft__akns_discretization_2SPLIT3B</code>: Order of base method = 2, Degree = 3, Order of accuracy of splitting-scheme = 3<br  />
 <code>fnft__akns_discretization_2SPLIT3S</code>: Order of base method = 2, Degree = 2, Order of accuracy of splitting-scheme = 3<br  />
 <code>fnft__akns_discretization_2SPLIT4A</code>: Order of base method = 2, Degree = 4, Order of accuracy of splitting-scheme = 4<br  />
 <code>fnft__akns_discretization_2SPLIT4B</code>: Order of base method = 2, Degree = 2, Order of accuracy of splitting-scheme = 4<br  />
 <code>fnft__akns_discretization_2SPLIT5A</code>: Order of base method = 2, Degree = 15, Order of accuracy of splitting-scheme = 5<br  />
 <code>fnft__akns_discretization_2SPLIT5B</code>: Order of base method = 2, Degree = 15, Order of accuracy of splitting-scheme = 5<br  />
 <code>fnft__akns_discretization_2SPLIT6A</code>: Order of base method = 2, Degree = 12, Order of accuracy of splitting-scheme = 6<br  />
 <code>fnft__akns_discretization_2SPLIT6B</code>: Order of base method = 2, Degree = 6, Order of accuracy of splitting-scheme = 6<br  />
 <code>fnft__akns_discretization_2SPLIT7A</code>: Order of base method = 2, Degree = 105, Order of accuracy of splitting-scheme = 7<br  />
 <code>fnft__akns_discretization_2SPLIT7B</code>: Order of base method = 2, Degree = 105, Order of accuracy of splitting-scheme = 7<br  />
 <code>fnft__akns_discretization_2SPLIT8A</code>: Order of base method = 2, Degree = 24, Order of accuracy of splitting-scheme = 8<br  />
 <code>fnft__akns_discretization_2SPLIT8B</code>: Order of base method = 2, Degree = 12, Order of accuracy of splitting-scheme = 8<br  />
 <code>fnft__akns_discretization_4SPLIT4A</code>: Order of base method = 4, Degree = 4, Order of accuracy of splitting-scheme = 4<br  />
 <code>fnft__akns_discretization_4SPLIT4B</code>: Order of base method = 4, Degree = 2, Order of accuracy of splitting-scheme = 4</p>
<p>Used in <a class="el" href="fnft____akns__fscatter_8h.html">fnft__akns_fscatter.h</a> and <a class="el" href="fnft____akns__scatter_8h.html">fnft__akns_scatter.h</a>. </p>

</div>
</div>
<a id="ga98007ff9d80f79fe3a33663502c256de" name="ga98007ff9d80f79fe3a33663502c256de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98007ff9d80f79fe3a33663502c256de">&#9670;&#160;</a></span>fnft__akns_pde_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#ga98007ff9d80f79fe3a33663502c256de">fnft__akns_pde_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum that specifies partial differential equations for which the nonlinear Fourier transform can be calculated with the AKNS framework. M. J. Ablowitz, D. J. Kaup, A. C. Newell, and H. Segur, “The inverse scattering transform - Fourier analysis for nonlinear problems,” Studies in Applied Mathematics, vol. 53, pp. 249–315, 12 1974. <code>fnft__akns_pde_KdV</code> &ndash; Korteweg-de Vries equation: </p>
<p class="formulaDsp">
\[ q_x + 6qq_{t} + q_{ttt}=0, \quad  q=q(x,t). \]
</p>
<p> <code>fnft__akns_pde_NSE</code> &ndash; Nonlinear Schrödinger equation: </p><p class="formulaDsp">
\[ iq_x + q_{tt} \pm 2q|q|^2=0, \quad  q=q(x,t), \]
</p>
 
</div>
</div>
<a id="ga10835ef19579608a235d4cee906b286c" name="ga10835ef19579608a235d4cee906b286c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10835ef19579608a235d4cee906b286c">&#9670;&#160;</a></span>fnft_kdv_discretization_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#ga10835ef19579608a235d4cee906b286c">fnft_kdv_discretization_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum that specifies discretizations and methods used to compute nonlinear Fourier transforms for the Korteweg-de Vries Equation. </p>
<p>Discretizations that exist with and without the addition <code>_VANILLA</code> are all in AKNS basis. The ones with the addition '_VANILLA' put the potential in <code>q</code> and set <code>r</code> to -1, like proposed in the AKNS Paper: M. J. Ablowitz, D. J. Kaup, A. C. Newell, and H. Segur, <a href="https://doi.org/10.1002/sapm1974534249">&quot;The inverse scattering transform - Fourier analysis for nonlinear problems&quot;, Studies in Applied Mathematics, vol. 53, pp. 249–315, 12 1974. </a>. The ones without the addition '_VANILLA' put the potential in <code>r</code> and set <code>q</code> to -1, which appears to be more suitable for numerical calculations.<br  />
 Each discretization is always related to a particular numerical method and some are additionally related to a splitting-scheme.<br  />
 <code>fnft_kdv_discretization_BO(_VANILLA)</code> have been taken from Boffetta and Osborne, <a href="https://doi.org/10.1016/0021-9991(92)90370-E">&quot; Computation of the direct scattering transform for the nonlinear Schroedinger equation,&quot;</a> J. Comput. Phys. 102(2), 1992.<br  />
 <code>fnft_kdv_discretization_CFx_y</code> are from Chimmalgi, Prins and Wahls, <a href="https://doi.org/10.1109/ACCESS.2019.2945480">&quot; Fast Nonlinear Fourier Transform Algorithms Using Higher Order Exponential Integrators,&quot;</a> IEEE Access 7, 2019. They are higher-order commutator-free exponential integrators with <code>x</code> denoting the order of the method and <code>y</code> the number of matrix exponentials required per signal sample. <br  />
 <code>fnft_kdv_discretization_ES4(_VANILLA)</code> and <code>fnft_kdv_discretization_TES4(_VANILLA)</code> are fourth-order methods from Medvedev, Vaseva, Chekhovskoy and Fedoruk <a href="https://doi.org/10.1364/OE.377140">&quot; Exponential fourth order schemes for direct Zakharov-Shabat problem,&quot;</a> Optics Express, vol. 28, pp. 20&ndash;39, 2020.<br  />
 All above discretizations only support Newton method based bound states localization (see fnft_kdvv_bsloc_NEWTON of type <a class="el" href="group__data__types.html#ga7165be78ff704ce76877adb43dfa87cc">fnft_kdvv_bsloc_t</a>) in <a class="el" href="group__fnft.html#ga944e84c5d6d91142b8e062a3aa2e497d">fnft_kdvv</a>. <br  />
 The exponential spliting schemes, defined in Prins and Wahls, <a href="https://doi.org/10.1109/ICASSP.2018.8461708">&quot; Higher order exponential splittings for the fast non-linear Fourier transform of the KdV equation,&quot; </a>Proc. ICASSP 2018, pp. 4524-4528 have been applied to the second-order method by Boffetta and Osborne and to the fourth-order CF4_2 method to obtain other discretizations.<br  />
 The <code>fnft_kdv_discretization_2SPLIT2_MODAL(_VANILLA)</code> discretization is an exception. It is the normalized Ablowitz-Ladik discretization Eq. 25 in Wahls and Vaibhav<a href="https://arxiv.org/pdf/1607.01305v2.pdf">&quot; Fast Inverse Nonlinear Fourier Transforms for Continuous Spectra of Zakharov-Shabat Type ,&quot;</a> Unpublished.<br  />
 All other discretizations have the notation <code>xSPLITyz</code>, where <code>x</code> is the error order of the base numerical method and <code>y</code> is the order of accuracy of splitting scheme. <code>z</code> is type of splitting and can be <code>A</code>, <code>B</code> or <code>S</code>, with <code>A</code> standing for schemes implemented as defined in Prins and Wahls, <a href="https://doi.org/10.1109/ICASSP.2018.8461708">&quot; Higher order exponential splittings for the fast non-linear Fourier transform of the KdV equation,&quot; </a>Proc. ICASSP 2018, pp. 4524-4528. <code>B</code> type of splitting are the same as <code>A</code> with the positions of the two terms in the splitting interchanged. <code>S</code> is for splittings not mentioned in above reference.<br  />
 <code>-2S</code> is from G. Strang,<a href="https://link.springer.com/content/pdf/10.1007/BF00281235.pdf">&quot; Accurate partial difference methods I: Linear Cauchy problems,&quot;</a> in Archive for Rational Mechanics and Analysis, 12(1), 392-402, Jan 1963. It is also known as the Symmetric Weighted Sequential Splitting scheme (SWSS).<br  />
 <code>-3S</code> is from Eq. 14.4 in S. Brustein and A. Mirin,<a href="https://doi.org/10.1016/0021-9991(70)90080-X">&quot; Third Order Difference Methods for Hyperbolic Equations,&quot;</a> J. Comput. Phys., 5, 547-571, 1970.<br  />
 <code>fnft_kdv_discretization_BO</code> has been taken from Boffetta and Osborne, <a href="https://doi.org/10.1016/0021-9991(92)90370-E">&quot; Computation of the direct scattering transform for the nonlinear Schroedinger equation,&quot;</a> J. Comput. Phys. 102(2), 1992. It is supported by <a class="el" href="fnft____kdv__scatter_8h.html">fnft__kdv_scatter.h</a>.<br  />
 <code>fnft_kdv_discretization_CFx_y</code> are from Chimmalgi, Prins and Wahls, <a href="https://doi.org/10.1109/ACCESS.2019.2945480">&quot; Fast Nonlinear Fourier Transform Algorithms Using Higher Order Exponential Integrators,&quot;</a> IEEE Access 7, 2019. They are higher-order commutator-free exponential integrators with <code>x</code> denoting the order of the method and <code>y</code> the number of matrix exponentials required per signal sample. They are supported by <a class="el" href="fnft____kdv__scatter_8h.html">fnft__kdv_scatter.h</a>.<br  />
 In general, discretizations with a lower degree are faster, while those with a highter order of accuracy are more accurate. Therefore, the best choice is normally among <code>-2A</code>, <code>-2B</code>, <code>-2S</code> <code>-4B</code>, <code>-6B</code> and <code>-8B</code>. The choice between these is a trade-off between speed and accuracy.</p>
<p><code>fnft_kdv_discretization_2SPLIT1A(_VANILLA)</code>: Order of base method = 2, Degree = 1, Order of accuracy of splitting-scheme = 1<br  />
 <code>fnft_kdv_discretization_2SPLIT1B(_VANILLA)</code>: Order of base method = 2, Degree = 1, Order of accuracy of splitting-scheme = 1<br  />
 <code>fnft_kdv_discretization_2SPLIT2A(_VANILLA)</code>: Order of base method = 2, Degree = 1, Order of accuracy of splitting-scheme = 2<br  />
 <code>fnft_kdv_discretization_2SPLIT2B(_VANILLA)</code>: Order of base method = 2, Degree = 1, Order of accuracy of splitting-scheme = 2<br  />
 <code>fnft_kdv_discretization_2SPLIT2S(_VANILLA)</code>: Order of base method = 2, Degree = 1, Order of accuracy of splitting-scheme = 2<br  />
 <code>fnft_kdv_discretization_2SPLIT2_MODAL(_VANILLA)</code>: Order of base method = 2, Degree = 1, Order of accuracy of splitting-scheme = 2<br  />
 <code>fnft_kdv_discretization_2SPLIT3A(_VANILLA)</code>: Order of base method = 2, Degree = 3, Order of accuracy of splitting-scheme = 3<br  />
 <code>fnft_kdv_discretization_2SPLIT3B(_VANILLA)</code>: Order of base method = 2, Degree = 3, Order of accuracy of splitting-scheme = 3<br  />
 <code>fnft_kdv_discretization_2SPLIT3S(_VANILLA)</code>: Order of base method = 2, Degree = 2, Order of accuracy of splitting-scheme = 3<br  />
 <code>fnft_kdv_discretization_2SPLIT4A(_VANILLA)</code>: Order of base method = 2, Degree = 4, Order of accuracy of splitting-scheme = 4<br  />
 <code>fnft_kdv_discretization_2SPLIT4B(_VANILLA)</code>: Order of base method = 2, Degree = 2, Order of accuracy of splitting-scheme = 4<br  />
 <code>fnft_kdv_discretization_2SPLIT5A(_VANILLA)</code>: Order of base method = 2, Degree = 15, Order of accuracy of splitting-scheme = 5<br  />
 <code>fnft_kdv_discretization_2SPLIT5B(_VANILLA)</code>: Order of base method = 2, Degree = 15, Order of accuracy of splitting-scheme = 5<br  />
 <code>fnft_kdv_discretization_2SPLIT6A(_VANILLA)</code>: Order of base method = 2, Degree = 12, Order of accuracy of splitting-scheme = 6<br  />
 <code>fnft_kdv_discretization_2SPLIT6B(_VANILLA)</code>: Order of base method = 2, Degree = 6, Order of accuracy of splitting-scheme = 6<br  />
 <code>fnft_kdv_discretization_2SPLIT7A(_VANILLA)</code>: Order of base method = 2, Degree = 105, Order of accuracy of splitting-scheme = 7<br  />
 <code>fnft_kdv_discretization_2SPLIT7B(_VANILLA)</code>: Order of base method = 2, Degree = 105, Order of accuracy of splitting-scheme = 7<br  />
 <code>fnft_kdv_discretization_2SPLIT8A(_VANILLA)</code>: Order of base method = 2, Degree = 24, Order of accuracy of splitting-scheme = 8<br  />
 <code>fnft_kdv_discretization_2SPLIT8B(_VANILLA)</code>: Order of base method = 2, Degree = 12, Order of accuracy of splitting-scheme = 8<br  />
 <code>fnft_kdv_discretization_4SPLIT4A(_VANILLA)</code>: Order of base method = 4, Degree = 4, Order of accuracy of splitting-scheme = 4<br  />
 <code>fnft_kdv_discretization_4SPLIT4B(_VANILLA)</code>: Order of base method = 4, Degree = 2, Order of accuracy of splitting-scheme = 4</p>
<p>Used in <a class="el" href="structfnft__kdvv__opts__t.html">fnft_kdvv_opts_t</a>. </p>

</div>
</div>
<a id="ga7165be78ff704ce76877adb43dfa87cc" name="ga7165be78ff704ce76877adb43dfa87cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7165be78ff704ce76877adb43dfa87cc">&#9670;&#160;</a></span>fnft_kdvv_bsloc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#ga7165be78ff704ce76877adb43dfa87cc">fnft_kdvv_bsloc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum that specifies how the bound states are localized. Used in <a class="el" href="structfnft__kdvv__opts__t.html">fnft_kdvv_opts_t</a>. <br  />
 <br  />
 fnft_kdvv_bsloc_NEWTON: Newton's method is used to refine a given set of initial guesses. The discretization used for the the refinement is one of the base methods <a class="el" href="fnft__kdv__discretization__t_8h.html">fnft_kdv_discretization_t.h</a>. The number of iterations is specified through the field <a class="el" href="structfnft__kdvv__opts__t.html#a7df7dd9af80c0fbf76327f0d5e1e0f16">fnft_kdvv_opts_t::niter</a>. The array bound_states passed to <a class="el" href="group__fnft.html#ga944e84c5d6d91142b8e062a3aa2e497d">fnft_kdvv</a> should contain the initial guesses and *K_ptr should specify the number of initial guesses. It is sufficient if bound_states and normconst_or_residues are of length *K_ptr in this case. This method can be very fast if good initial guesses for the bound states are available. The complexity is \( O(niter (*K\_ptr) D) \). <br  />
 <br  />
 fnft_kdvv_bsloc_GRIDSEARCH_AND_REFINE: The algorithm evaluates \( a(\xi) \) on the grid \( \xi = \{j nexttoward(0,1), jh,2jh,3jh,\ldots,(M-3)jh\,(M-2)jh,j nexttoward((M-1)h,0)\}\), where \( h:= \sqrt{c \max_t q(t)} / (M-1)\), where \( c=1\) for all second order discretizations, &lsquo;fnft_kdv_discretization_4SPLIT4A&rsquo;/'B'('_VANILLA'), and <code>fnft_kdv_discretization_CF4_2</code>(<code>_VANILLA</code>); \( c \) is approximately 2 for other discretizations. The constant \( M \) is chosen such that the distance between the neighboring grid points is not larger than the parameter <a class="el" href="structfnft__kdvv__opts__t.html#a1d0dbe86cdfed7f7d66f237e6341238f">fnft_kdvv_opts_t::grid_spacing</a>. This parameter therefore must be set if this algorithm is used. The sign changes of \( a(\xi) \) on this grid are used as initial guesses for the bound states, which are then refined as in <code>fnft_kdvv_bsloc_NEWTON</code>. </p>

</div>
</div>
<a id="ga96100b1d82129d86a29b0b2e77ab3c80" name="ga96100b1d82129d86a29b0b2e77ab3c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96100b1d82129d86a29b0b2e77ab3c80">&#9670;&#160;</a></span>fnft_kdvv_cstype_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#ga96100b1d82129d86a29b0b2e77ab3c80">fnft_kdvv_cstype_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum that specifies the type of the continuous spectrum computed by the routine. Used in <a class="el" href="structfnft__kdvv__opts__t.html">fnft_kdvv_opts_t</a>.<br  />
 <br  />
 fnft_kdvv_cstype_REFLECTION_COEFFICIENT: The array is filled with the values of \( b(\xi)/a(\xi) \) on the grid specified in the description of <a class="el" href="group__fnft.html#ga944e84c5d6d91142b8e062a3aa2e497d">fnft_kdvv</a>. <br  />
<br  />
 fnft_kdvv_cstype_AB: The array is filled with the values of \(a(\xi)\) on the grid specified in the description of <a class="el" href="group__fnft.html#ga944e84c5d6d91142b8e062a3aa2e497d">fnft_kdvv</a>, followed by the values of \( b(\xi) \) on the same grid. Note that the length of the array contspec passed by the user has to be 2*M in this case.<br  />
<br  />
 fnft_kdvv_cstype_BOTH: The first M values of the array are filled with the values returned by the REFLECTION_COEFFICIENT method. They are followed by the 2*M values returned by the AB method. Note that the length of the array passed by the user has to be 3*M in this case. </p>

</div>
</div>
<a id="gaee315490ec1fae3f8eed2312f7b4adad" name="gaee315490ec1fae3f8eed2312f7b4adad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee315490ec1fae3f8eed2312f7b4adad">&#9670;&#160;</a></span>fnft_kdvv_dstype_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#gaee315490ec1fae3f8eed2312f7b4adad">fnft_kdvv_dstype_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum that specifies the type of the discrete spectrum computed by the routine. Used in <a class="el" href="structfnft__kdvv__opts__t.html">fnft_kdvv_opts_t</a>.<br  />
 <br  />
 fnft_kdvv_dstype_NORMING_CONSTANTS: The array is filled with the norming constants \( b_k \). <br  />
<br  />
 fnft_kdvv_dstype_RESIDUES: The array is filled with the residues (aka spectral amplitudes) \( b_k\big/\frac{da(\lambda_k)}{d\lambda} \). <br  />
 <br  />
 fnft_kdvv_dstype_BOTH: The array contains both, first the norming constants and then the residues. Note that the length of the array passed by the user has to be 2*(*K_ptr) in this case. </p>

</div>
</div>
<a id="gaedc0f9c54a7e031f4c34ce4fbe66333e" name="gaedc0f9c54a7e031f4c34ce4fbe66333e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedc0f9c54a7e031f4c34ce4fbe66333e">&#9670;&#160;</a></span>fnft_manakov_discretization_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#gaedc0f9c54a7e031f4c34ce4fbe66333e">fnft_manakov_discretization_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum that specifies discretizations and methods used to compute nonlinear Fourier transforms for the Manakov Equation. </p>
<p>Each discretization is always related to a particular numerical method and some are additionally related to a splitting-scheme.<br  />
FTES4_YZ and XSPLITYZ are methods to which an exponential splitting scheme defined by Prins and Wahls, <a href="https://doi.org/10.1109/ICASSP.2018.8461708">&quot; Higher Order Exponential Splittings for the Fast Non-Linear Fourier Transform of the Korteweg-De Vries Equation &quot;</a>, Proc. ICASSP 2018, has been applied.<br  />
For FTES4_YZ, the base method is the TES4 method from Medvedev, Vaseva, Chekhovskoy and Fedoruk <a href="https://doi.org/10.1364/OE.377140">&quot; Exponential fourth order schemes for direct Zakharov-Shabat problem &quot;</a>, Optics Express 28(1) 2020.<br  />
For XSPLITYZ X denotes the order of the base method. For X=2 the second order method by Boffetta and Osborne from <a href="https://doi.org/10.1016/0021-9991(92)90370-E">&quot;Computation of the direct scattering transform for the nonlinear Schroedinger equation &quot;</a> J. Comput. Phys. 102(2), 1992, has been chosen. For X=4 the base method is the fourth order method CF4_2 from Chimmalgi, Prins and Wahls, <a href="https://doi.org/10.1109/ACCESS.2019.2945480">&quot;Fast Nonlinear Fourier Transform Algorithms Using Higher Order Exponential Integrators&quot;</a>, IEEE Access (7) 2019.<br  />
For FTES4_YZ and XSPLITYZ, Y denotes the order of the chosen exponential splitting scheme from Prins and Wahls, <a href="https://doi.org/10.1109/ICASSP.2018.8461708">&quot; Higher order exponential splittings for the fast non-linear Fourier transform of the KdV equation,&quot; </a>Proc. ICASSP 2018, pp. <code>z</code> is type of splitting and can be <code>A</code> or <code>B, with</code>A<code>standing for schemes implemented as defined in Prins and Wahls, &lt;a href="https://doi.org/10.1109/ICASSP.2018.8461708"&gt;&amp;quot; Higher order exponential splittings for the fast non-linear Fourier transform of the KdV equation,&amp;quot; &lt;/a&gt;Proc. ICASSP 2018, pp. 4524-4528.</code>B<code>type of splitting are the same as</code>A<code>with the positions of the two terms in the splitting interchanged.\n FTES4_suzuki is the FTES4 method where suzuki factorization (&lt;a href="https://journals.jps.jp/doi/10.1143/JPSJ.61.3015"&gt; J. Phys. Soc. Jpn. (1992)&lt;/a&gt;) was used to split the exponential term, as carried out by Medvedev, Chekhovskoy, Vaseva and Fedoruk in &lt;a href="https://www.osapublishing.org/ol/abstract.cfm?uri=ol-45-7-2082"&gt; &amp;quot; Conservative multi-exponential scheme for solving the direct Zakharov–Shabat scattering problem&amp;quot;&lt;/a&gt;, Optics Letters 45(7) 2020.\n In general, discretizations with a lower degree are faster, while those with a highter order of accuracy are more accurate. Therefore, the best choice is normally among</code>-2A<code>,</code>-2B<code>,</code>-4B<code>,</code>-6B`. The choice between these is a trade-off between speed and accuracy.<br  />
 Fast discretizations implemented for the Manakov equation: (degree denotes the polynomial degree of a single transition matrix)<br  />
<code>fnft_manakov_discretization_2SPLIT3A</code>: Order of base method = 2, Degree = 6, Order of accuracy splitting-scheme = 3<br  />
<code>fnft_manakov_discretization_2SPLIT3B</code>: Order of base method = 2, Degree = 6, Order of accuracy splitting-scheme = 3<br  />
<code>fnft_manakov_discretization_2SPLIT4A</code>: Order of base method = 2, Degree = 8, Order of accuracy splitting-scheme = 4<br  />
<code>fnft_manakov_discretization_2SPLIT4B</code>: Order of base method = 2, Degree = 4, Order of accuracy splitting-scheme = 4<br  />
<code>fnft_manakov_discretization_2SPLIT6B</code>: Order of base method = 2, Degree = 12, Order of accuracy splitting-scheme = 6<br  />
<code>fnft_manakov_discretization_4SPLIT4A</code>: Order of base method = 4, Degree = 8, Order of accuracy splitting-scheme = 4<br  />
<code>fnft_manakov_discretization_4SPLIT4B</code>: Order of base method = 4, Degree = 4, Order of accuracy splitting-scheme = 4<br  />
<code>fnft_manakov_discretization_4SPLIT6B</code>: Order of base method = 4, Degree = 12, Order of accuracy splitting-scheme = 6<br  />
<code>fnft_manakov_discretization_FTES4_4A</code>: Order of base method = 4, Degree = 8, Order of accuracy splitting-scheme = 4<br  />
<code>fnft_manakov_discretization_FTES4_4B</code>: Order of base method = 4, Degree = 8, Order of accuracy splitting-scheme = 4<br  />
<code>fnft_manakov_discretization_FTES4_suzuki</code>: Order of base method = 4, Degree = 14, Order of accuracy splitting-scheme = 4<br  />
 Slow methods implemented for the Manakov equation:<br  />
<code>fnft_manakov_discretization_CF4_2</code>: base method for the 4SPLITYZ methods<br  />
<code>fnft_manakov_discretization_BO</code>: base method for the 2SPLITYZ methods<br  />
 Used in <a class="el" href="structfnft__manakovv__opts__t.html">fnft_manakovv_opts_t</a>. </p>

</div>
</div>
<a id="gac0332f0ca69331fdc6fb1c3f8a3985a9" name="gac0332f0ca69331fdc6fb1c3f8a3985a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0332f0ca69331fdc6fb1c3f8a3985a9">&#9670;&#160;</a></span>fnft_manakovv_bsfilt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#gac0332f0ca69331fdc6fb1c3f8a3985a9">fnft_manakovv_bsfilt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum that specifies how the bound states are filtered. Used in <a class="el" href="structfnft__manakovv__opts__t.html">fnft_manakovv_opts_t</a>.<br  />
 <br  />
 fnft_nsev_bsfilt_NONE: All detected roots of \( a(\lambda) \) are returned. <br  />
 <br  />
 fnft_nsev_bsfilt_BASIC: Only roots in the upper halfplane are returned and roots very close to each other are merged. <br  />
 <br  />
 fnft_nsev_bsfilt_FULL: NOT YET IMPLEMENTED. </p>

</div>
</div>
<a id="ga621a1e5cb0ae2393088aed46e9ea3abc" name="ga621a1e5cb0ae2393088aed46e9ea3abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga621a1e5cb0ae2393088aed46e9ea3abc">&#9670;&#160;</a></span>fnft_manakovv_bsloc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#ga621a1e5cb0ae2393088aed46e9ea3abc">fnft_manakovv_bsloc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum that specifies how the bound states are localized. Used in <a class="el" href="structfnft__manakovv__opts__t.html">fnft_manakovv_opts_t</a>. <br  />
 <br  />
 fnft_nsev_bsloc_FAST_EIGENVALUE: A root finding routine due to Aurentz et al. (see <a href="https://arxiv.org/abs/1611.02435">https://arxiv.org/abs/1611.02435</a> and <a href="https://github.com/eiscor/eiscor">https://github.com/eiscor/eiscor</a>) with \( O(D^2) \) complexity is used to detect the roots of \( a(\lambda) \). (Note: FNFT incorporates a development version of this routine as no release was available yet.) This method is relatively slow, but very reliable. <br  />
 <br  />
 fnft_nsev_bsloc_NEWTON: NOT YET IMPLEMENTED. fnft_nsev_bsloc_SUBSAMPLE_AND_REFINE: NOT YET IMPLEMENTED. </p>

</div>
</div>
<a id="gaf98843a45007d9bb52e4a027e7324d38" name="gaf98843a45007d9bb52e4a027e7324d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf98843a45007d9bb52e4a027e7324d38">&#9670;&#160;</a></span>fnft_manakovv_cstype_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#gaf98843a45007d9bb52e4a027e7324d38">fnft_manakovv_cstype_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum that specifies the type of the continuous spectrum computed by the routine. Used in <a class="el" href="structfnft__manakovv__opts__t.html">fnft_manakovv_opts_t</a>.<br  />
 <br  />
 fnft_manakovv_cstype_REFLECTION_COEFFICIENT: The array is filled with the values of \( b1(\xi)/a(\xi) \) followed by the values of \( b2(\xi)/a(\xi) \) on the grid specified in the description of <a class="el" href="group__fnft.html#ga2dd02971674ab93cdb07ea3620ece96d">fnft_manakovv</a>. The length of contspec should be 2*M in this case. <br  />
<br  />
 fnft_manakovv_cstype_AB: The array is filled with the values of \(a(\xi)\) on the grid specified in the description of <a class="el" href="group__fnft.html#ga2dd02971674ab93cdb07ea3620ece96d">fnft_manakovv</a>, followed by the values of \( b1(\xi) \) and \( b2(\xi) \) on the same grid. Note that the length of the array contspec passed by the user has to be 3*M in this case.<br  />
<br  />
 fnft_manakovv_cstype_BOTH: The first 2*M values of the array are filled with the values returned by the REFLECTION_COEFFICIENT method. They are followed by the 3*M values returned by the AB method. Note that the length of the array passed by the user has to be 5*M in this case. </p>

</div>
</div>
<a id="ga6cfffa33b6143046ac4a6f80648b61a6" name="ga6cfffa33b6143046ac4a6f80648b61a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cfffa33b6143046ac4a6f80648b61a6">&#9670;&#160;</a></span>fnft_manakovv_dstype_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#ga6cfffa33b6143046ac4a6f80648b61a6">fnft_manakovv_dstype_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum that specifies the type of the discrete spectrum computed by the routine. Used in <a class="el" href="structfnft__manakovv__opts__t.html">fnft_manakovv_opts_t</a>. CURRENTLY NOT USED SINCE ONLY THE BOUND STATES THEMSELVES ARE COMPUTED AT THE MOMENT. </p>

</div>
</div>
<a id="gac7910f5e26ab68217ed7d6565c539d1b" name="gac7910f5e26ab68217ed7d6565c539d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7910f5e26ab68217ed7d6565c539d1b">&#9670;&#160;</a></span>fnft_nse_discretization_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#gac7910f5e26ab68217ed7d6565c539d1b">fnft_nse_discretization_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum that specifies discretizations and methods used to compute nonlinear Fourier transforms for the Nonlinear Schroedinger Equation. </p>
<p>Each discretization is always related to a particular numerical method and some are additionally related to a splitting-scheme.<br  />
 <code>fnft_nse_discretization_BO</code> has been taken from Boffetta and Osborne, <a href="https://doi.org/10.1016/0021-9991(92)90370-E">&quot; Computation of the direct scattering transform for the nonlinear Schroedinger equation,&quot;</a> J. Comput. Phys. 102(2), 1992.<br  />
 <code>fnft_nse_discretization_CFx_y</code> are from Chimmalgi, Prins and Wahls, <a href="https://doi.org/10.1109/ACCESS.2019.2945480">&quot; Fast Nonlinear Fourier Transform Algorithms Using Higher Order Exponential Integrators,&quot;</a> IEEE Access 7, 2019. They are higher-order commutator-free exponential integrators with <code>x</code> denoting the order of the method and <code>y</code> the number of matrix exponentials required per signal sample. <br  />
 <code>fnft_nse_discretization_ES4</code> and <code>fnft_nse_discretization_TES4</code> are fourth-order methods from Medvedev, Vaseva, Chekhovskoy and Fedoruk <a href="https://doi.org/10.1364/OE.377140">&quot; Exponential fourth order schemes for direct Zakharov-Shabat problem,&quot;</a> Optics Express, vol. 28, pp. 20&ndash;39, 2020.<br  />
 All above discretizations only support Newton method based bound states localization (see fnft_nsev_bsloc_NEWTON of type <a class="el" href="group__data__types.html#ga9ebbf0382d833e9fb91af6c5a5675cee">fnft_nsev_bsloc_t</a>) in <a class="el" href="group__fnft.html#gaa5d8a57faa42b4a86797ed3c829e7c0f">fnft_nsev</a>. <br  />
 The exponential spliting schemes, defined in Prins and Wahls, <a href="https://doi.org/10.1109/ICASSP.2018.8461708">&quot; Higher order exponential splittings for the fast non-linear Fourier transform of the KdV equation,&quot; </a>Proc. ICASSP 2018, pp. 4524-4528 have been applied to the second-order method by Boffetta and Osborne and to the fourth-order CF4_2 method to obtain other discretizations.<br  />
 The <code>fnft_nse_discretization_2SPLIT2_MODAL</code> discretization is an exception. It is the normalized Ablowitz-Ladik discretization Eq. 25 in Wahls and Vaibhav<a href="https://arxiv.org/pdf/1607.01305v2.pdf">&quot; Fast Inverse Nonlinear Fourier Transforms for Continuous Spectra of Zakharov-Shabat Type ,&quot;</a> Unpublished.<br  />
 All other discretizations have the notation <code>xSPLITyz</code>, where <code>x</code> is the error order of the base numerical method and <code>y</code> is the order of accuracy of splitting scheme. <code>z</code> is type of splitting and can be <code>A</code>, <code>B</code> or <code>S</code>, with <code>A</code> standing for schemes implemented as defined in Prins and Wahls, <a href="https://doi.org/10.1109/ICASSP.2018.8461708">&quot; Higher order exponential splittings for the fast non-linear Fourier transform of the KdV equation,&quot; </a>Proc. ICASSP 2018, pp. 4524-4528. <code>B</code> type of splitting are the same as <code>A</code> with the positions of the two terms in the splitting interchanged. <code>S</code> is for splittings not mentioned in above reference.<br  />
 <code>-2S</code> is from G. Strang,<a href="https://link.springer.com/content/pdf/10.1007/BF00281235.pdf">&quot; Accurate partial difference methods I: Linear Cauchy problems,&quot;</a> in Archive for Rational Mechanics and Analysis, 12(1), 392-402, Jan 1963. It is also known as the Symmetric Weighted Sequential Splitting scheme (SWSS).<br  />
<code>-3S</code> is from Eq. 14.4 in S. Brustein and A. Mirin,<a href="https://doi.org/10.1016/0021-9991(70)90080-X">&quot; Third Order Difference Methods for Hyperbolic Equations,&quot;</a> J. Comput. Phys., 5, 547-571, 1970.<br  />
 In general, discretizations with a lower degree are faster, while those with a highter order of accuracy are more accurate. Therefore, the best choice is normally among <code>-2A</code>, <code>-2B</code>, <code>-2S</code> <code>-4B</code>, <code>-6B</code> and <code>-8B</code>. The choice between these is a trade-off between speed and accuracy.</p>
<p><code>fnft_nse_discretization_2SPLIT1A</code>: Order of base method = 2, Degree = 1, Order of accuracy of splitting-scheme = 1<br  />
 <code>fnft_nse_discretization_2SPLIT1B</code>: Order of base method = 2, Degree = 1, Order of accuracy of splitting-scheme = 1<br  />
 <code>fnft_nse_discretization_2SPLIT2A</code>: Order of base method = 2, Degree = 1, Order of accuracy of splitting-scheme = 2<br  />
 <code>fnft_nse_discretization_2SPLIT2B</code>: Order of base method = 2, Degree = 1, Order of accuracy of splitting-scheme = 2<br  />
 <code>fnft_nse_discretization_2SPLIT2S</code>: Order of base method = 2, Degree = 1, Order of accuracy of splitting-scheme = 2<br  />
 <code>fnft_nse_discretization_2SPLIT2_MODAL</code>: Order of base method = 2, Degree = 1, Order of accuracy of splitting-scheme = 2<br  />
 <code>fnft_nse_discretization_2SPLIT3A</code>: Order of base method = 2, Degree = 3, Order of accuracy of splitting-scheme = 3<br  />
 <code>fnft_nse_discretization_2SPLIT3B</code>: Order of base method = 2, Degree = 3, Order of accuracy of splitting-scheme = 3<br  />
 <code>fnft_nse_discretization_2SPLIT3S</code>: Order of base method = 2, Degree = 2, Order of accuracy of splitting-scheme = 3<br  />
 <code>fnft_nse_discretization_2SPLIT4A</code>: Order of base method = 2, Degree = 4, Order of accuracy of splitting-scheme = 4<br  />
 <code>fnft_nse_discretization_2SPLIT4B</code>: Order of base method = 2, Degree = 2, Order of accuracy of splitting-scheme = 4<br  />
 <code>fnft_nse_discretization_2SPLIT5A</code>: Order of base method = 2, Degree = 15, Order of accuracy of splitting-scheme = 5<br  />
 <code>fnft_nse_discretization_2SPLIT5B</code>: Order of base method = 2, Degree = 15, Order of accuracy of splitting-scheme = 5<br  />
 <code>fnft_nse_discretization_2SPLIT6A</code>: Order of base method = 2, Degree = 12, Order of accuracy of splitting-scheme = 6<br  />
 <code>fnft_nse_discretization_2SPLIT6B</code>: Order of base method = 2, Degree = 6, Order of accuracy of splitting-scheme = 6<br  />
 <code>fnft_nse_discretization_2SPLIT7A</code>: Order of base method = 2, Degree = 105, Order of accuracy of splitting-scheme = 7<br  />
 <code>fnft_nse_discretization_2SPLIT7B</code>: Order of base method = 2, Degree = 105, Order of accuracy of splitting-scheme = 7<br  />
 <code>fnft_nse_discretization_2SPLIT8A</code>: Order of base method = 2, Degree = 24, Order of accuracy of splitting-scheme = 8<br  />
 <code>fnft_nse_discretization_2SPLIT8B</code>: Order of base method = 2, Degree = 12, Order of accuracy of splitting-scheme = 8<br  />
 <code>fnft_nse_discretization_4SPLIT4A</code>: Order of base method = 4, Degree = 4, Order of accuracy of splitting-scheme = 4<br  />
 <code>fnft_nse_discretization_4SPLIT4B</code>: Order of base method = 4, Degree = 2, Order of accuracy of splitting-scheme = 4</p>
<p>Used in <a class="el" href="structfnft__nsev__opts__t.html">fnft_nsev_opts_t</a>, <a class="el" href="structfnft__nsep__opts__t.html">fnft_nsep_opts_t</a> and <a class="el" href="structfnft__nsev__inverse__opts__t.html">fnft_nsev_inverse_opts_t</a>. </p>

</div>
</div>
<a id="ga648f442b682061a897c83f78de962dd1" name="ga648f442b682061a897c83f78de962dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga648f442b682061a897c83f78de962dd1">&#9670;&#160;</a></span>fnft_nsep_filt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#ga648f442b682061a897c83f78de962dd1">fnft_nsep_filt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum that controls how spectrum is filtered. Used in <a class="el" href="structfnft__nsep__opts__t.html">fnft_nsep_opts_t</a>.<br  />
 <br  />
 fnft_nsep_opts_filt_NONE: No filtering.<br  />
<br  />
 fnft_nsep_opts_filt_MANUAL: Only points within the specified <a class="el" href="structfnft__nsep__opts__t.html#a41219017fbc385cae73e58fec74b5b08">fnft_nsep_opts_t::bounding_box</a> are kept. <br  />
<br  />
 fnft_nsep_opts_filt_AUTO: As above, but the boundary box is chosen by the routine. </p>

</div>
</div>
<a id="ga844c6b6fe944797f846f896a14734eeb" name="ga844c6b6fe944797f846f896a14734eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga844c6b6fe944797f846f896a14734eeb">&#9670;&#160;</a></span>fnft_nsep_loc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#ga844c6b6fe944797f846f896a14734eeb">fnft_nsep_loc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum that controls how spectrum is localized. Used in <a class="el" href="structfnft__nsep__opts__t.html">fnft_nsep_opts_t</a>.<br  />
 <br  />
 fnft_nsep_opts_loc_SUBSAMPLE_AND_REFINE: Similar approach as for fnft_nsev_opts_dsloc_SUBSAMPLE_AND_REFINE (see <a class="el" href="structfnft__nsev__opts__t.html#ad8f2e116bc872e8a986ed9e068e4fb5b">fnft_nsev_opts_t::bound_state_localization</a>.)<br  />
<br  />
 fnft_nsep_opts_loc_NEWTON: Refine initial guesses for the main and/or auxiliary spectrum by the user using Newton's method.<br  />
<br  />
 fnft_nsev_opts_dsloc_SUBSAMPLE_AND_REFINE (see <a class="el" href="structfnft__nsev__opts__t.html#ad8f2e116bc872e8a986ed9e068e4fb5b">fnft_nsev_opts_t::bound_state_localization</a>.)<br  />
<br  />
 fnft_nsep_opts_loc_GRIDSEARCH: Uses a grid search to localize roots. Can only find main and auxiliary spectrum points on the real axis. In the defocusing case, the main spectrum is always real. The implemented grid search gurantees only linear convergence.<br  />
<br  />
 fnft_nsep_opts_loc_MIXED: Uses the SUBSAMPLE_AND_REFINE method to find the non-real parts of the spectra and the GRIDSEARCH method to find the real parts. </p>

</div>
</div>
<a id="gab42605e09c16a68525a77b09ef10a9e5" name="gab42605e09c16a68525a77b09ef10a9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab42605e09c16a68525a77b09ef10a9e5">&#9670;&#160;</a></span>fnft_nsev_bsfilt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#gab42605e09c16a68525a77b09ef10a9e5">fnft_nsev_bsfilt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum that specifies how the bound states are filtered. Used in <a class="el" href="structfnft__nsev__opts__t.html">fnft_nsev_opts_t</a>.<br  />
 <br  />
 fnft_nsev_bsfilt_NONE: All detected roots of \( a(\lambda) \) are returned. <br  />
 <br  />
 fnft_nsev_bsfilt_BASIC: Only roots in the upper halfplane are returned and roots very close to each other are merged. <br  />
 <br  />
 fnft_nsev_bsfilt_FULL: Bound states in physically implausible regions and outside the region based on the step-size of the supplied samples are rejected. <br  />
 <br  />
 fnft_nsev_opts_filt_MANUAL: Only points within the specified <a class="el" href="structfnft__nsev__opts__t.html#a5b4c344211cecca3427179d2e3a3ceb7">fnft_nsev_opts_t::bounding_box</a> are kept. <br  />
<br  />
</p>

</div>
</div>
<a id="ga9ebbf0382d833e9fb91af6c5a5675cee" name="ga9ebbf0382d833e9fb91af6c5a5675cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ebbf0382d833e9fb91af6c5a5675cee">&#9670;&#160;</a></span>fnft_nsev_bsloc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#ga9ebbf0382d833e9fb91af6c5a5675cee">fnft_nsev_bsloc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum that specifies how the bound states are localized. Used in <a class="el" href="structfnft__nsev__opts__t.html">fnft_nsev_opts_t</a>. <br  />
 <br  />
 fnft_nsev_bsloc_FAST_EIGENVALUE: A root finding routine due to Aurentz et al. (see <a href="https://arxiv.org/abs/1611.02435">https://arxiv.org/abs/1611.02435</a> and <a href="https://github.com/eiscor/eiscor">https://github.com/eiscor/eiscor</a>) with \( O(D^2) \) complexity is used to detect the roots of \( a(\lambda) \). (Note: FNFT incorporates a development version of this routine as no release was available yet.) This method is relatively slow. <br  />
 <br  />
 fnft_nsev_bsloc_NEWTON: Newton's method is used to refine a given set of initial guesses. The discretization used for the the refinement is one of the base methods <a class="el" href="fnft__nse__discretization__t_8h.html">fnft_nse_discretization_t.h</a>. The number of iterations is specified through the field <a class="el" href="structfnft__nsev__opts__t.html#a42455975b8725d83a5b534488234b69d">fnft_nsev_opts_t::niter</a>. The array bound_states passed to <a class="el" href="group__fnft.html#gaa5d8a57faa42b4a86797ed3c829e7c0f">fnft_nsev</a> should contain the initial guesses and *K_ptr should specify the number of initial guesses. It is sufficient if bound_states and normconst_or_residues are of length *K_ptr in this case. This method can be very fast if good initial guesses for the bound states are available. The complexity is \( O(niter (*K\_ptr) D) \). <br  />
 <br  />
 fnft_nsev_bsloc_SUBSAMPLE_AND_REFINE: This method offers a good compromise between the previous two. The method automatically finds initial guesses for the NEWTON method by first applying the FAST_EIGENVALUE method to a subsampled version of the signal. Second these initial guesses are refined using the NEWTON method. The number of samples of the subsampled signal can be controlled using the parameter Dsub in <a class="el" href="structfnft__nsev__opts__t.html">fnft_nsev_opts_t</a>. If Dsub=0, the routine automatically chooses this number such that the complexity is \( O(D \log^2 D + niter K D) \), where \( K \) is the number of bound states that survived the filtering operation of the initial call to the fnft_nsev_bsloc_FAST_EIGENVALUE method w.r.t. the subsampled signal. By choosing Dsub between 2 and D, the user can be request a different number of samples. Note that algorithm uses this value only as an indication. </p>

</div>
</div>
<a id="ga6e14d44f071521723b416a1d44433b1e" name="ga6e14d44f071521723b416a1d44433b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e14d44f071521723b416a1d44433b1e">&#9670;&#160;</a></span>fnft_nsev_cstype_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#ga6e14d44f071521723b416a1d44433b1e">fnft_nsev_cstype_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum that specifies the type of the continuous spectrum computed by the routine. Used in <a class="el" href="structfnft__nsev__opts__t.html">fnft_nsev_opts_t</a>.<br  />
 <br  />
 fnft_nsev_cstype_REFLECTION_COEFFICIENT: The array is filled with the values of \( b(\xi)/a(\xi) \) on the grid specified in the description of <a class="el" href="group__fnft.html#gaa5d8a57faa42b4a86797ed3c829e7c0f">fnft_nsev</a>. <br  />
<br  />
 fnft_nsev_cstype_AB: The array is filled with the values of \(a(\xi)\) on the grid specified in the description of <a class="el" href="group__fnft.html#gaa5d8a57faa42b4a86797ed3c829e7c0f">fnft_nsev</a>, followed by the values of \( b(\xi) \) on the same grid. Note that the length of the array contspec passed by the user has to be 2*M in this case.<br  />
<br  />
 fnft_nsev_cstype_BOTH: The first M values of the array are filled with the values returned by the REFLECTION_COEFFICIENT method. They are followed by the 2*M values returned by the AB method. Note that the length of the array passed by the user has to be 3*M in this case. </p>

</div>
</div>
<a id="gaf3d9c4fed6adc1ccf08e907d295cc41b" name="gaf3d9c4fed6adc1ccf08e907d295cc41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3d9c4fed6adc1ccf08e907d295cc41b">&#9670;&#160;</a></span>fnft_nsev_dstype_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#gaf3d9c4fed6adc1ccf08e907d295cc41b">fnft_nsev_dstype_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum that specifies the type of the discrete spectrum computed by the routine. Used in <a class="el" href="structfnft__nsev__opts__t.html">fnft_nsev_opts_t</a>.<br  />
 <br  />
 fnft_nsev_dstype_NORMING_CONSTANTS: The array is filled with the norming constants \( b_k \). <br  />
<br  />
 fnft_nsev_dstype_RESIDUES: The array is filled with the residues (aka spectral amplitudes) \( b_k\big/\frac{da(\lambda_k)}{d\lambda} \). <br  />
 <br  />
 fnft_nsev_dstype_BOTH: The array contains both, first the norming constants and then the residues. Note that the length of the array passed by the user has to be 2*(*K_ptr) in this case. </p>

</div>
</div>
<a id="ga2e8a23ea9190fbc59bc7d52832e5cc11" name="ga2e8a23ea9190fbc59bc7d52832e5cc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e8a23ea9190fbc59bc7d52832e5cc11">&#9670;&#160;</a></span>fnft_nsev_inverse_csmethod_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#ga2e8a23ea9190fbc59bc7d52832e5cc11">fnft_nsev_inverse_csmethod_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum that specifies which algorithm is used to invert the continuous spectrum. Used in <a class="el" href="structfnft__nsev__inverse__opts__t.html">fnft_nsev_inverse_opts_t</a>.<br  />
 <br  />
 fnft_nsev_inverse_csmethod_DEFAULT: <a class="el" href="group__fnft__inverse.html#ga96e7f068533c27369ce71f94b4c31bd1">fnft_nsev_inverse</a> chooses a default method based on the type of spectrum and whether we are in the defocusing case or not.<br  />
<br  />
 fnft_nsev_inverse_csmethod_TFMATRIX_CONTAINS_REFL_COEFF: This is essentially the algorithm in Section II of <a href="https://doi.org/10.1109/3.903065">[Skaar et al, J Quantum Electron 37(2), 2001]</a>, only that we use fast inverse scattering as in <a href="https://doi.org/10.1109/ISIT.2015.7282741">[Wahls &amp; Poor, Proc. IEEE ISIT 2015]</a>, <a href="https://doi.org/10.1190/1.1441417">[McClary, Geophysics 48(10), 1983] </a> instead of conventional layer peeling.<br  />
<br  />
 fnft_nsev_inverse_csmethod_TFMATRIX_CONTAINS_AB_FROM_ITER: This is Algorithm 1 in the unpublished preprint <a href="http://arxiv.org/abs/1607.01305v2">http://arxiv.org/abs/1607.01305v2</a> . The maximum number of iterations can be controlled using the max_iter field in <a class="el" href="structfnft__nsev__inverse__opts__t.html">fnft_nsev_inverse_opts_t</a>. Requires M=D. Defocusing case only.<br  />
<br  />
 fnft_nsev_inverse_csmethod_USE_SEED_POTENTIAL_INSTEAD: This algorithm adds discrete spectrum over the given seed potential. It uses Boffetta and Osborne (<a href="http://dx.doi.org/10.1016/0021-9991(92)90370-E">J. Comput. Physics 1992 </a>) method to compute the intermediate eigenfunctions and then uses the classical Darboux transform in <a href="https://doi.org/10.1007/BF02015338">[Lin, J. Acta Mathematicae Applicatae Sinica (1990) 6: 308]</a> to add the discrete spectrum. </p>

</div>
</div>
<a id="ga35417fabb6b4268a7c1c728ca57f16ff" name="ga35417fabb6b4268a7c1c728ca57f16ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35417fabb6b4268a7c1c728ca57f16ff">&#9670;&#160;</a></span>fnft_nsev_inverse_cstype_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#ga35417fabb6b4268a7c1c728ca57f16ff">fnft_nsev_inverse_cstype_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum that specifies in which form the continuous spectrum is provided. Used in <a class="el" href="structfnft__nsev__inverse__opts__t.html">fnft_nsev_inverse_opts_t</a>.<br  />
 <br  />
 fnft_nsev_inverse_cstype_REFLECTION_COEFFICIENT: The array contspec contains samples of \( b(\xi)/a(\xi) \) on the grid specified through the input XI to <a class="el" href="group__fnft__inverse.html#ga96e7f068533c27369ce71f94b4c31bd1">fnft_nsev_inverse</a>. <br  />
 <br  />
 fnft_nsev_inverse_cstype_B_OF_XI: The array contspec contains samples of \( b(\xi) \) on the grid specified through the input XI to <a class="el" href="group__fnft__inverse.html#ga96e7f068533c27369ce71f94b4c31bd1">fnft_nsev_inverse</a>. <br  />
 <br  />
 fnft_nsev_inverse_cstype_B_OF_TAU: The array contspec contains samples of the inverse Fourier transform \({ B(\tau) = \frac{1}{2\pi}
 \int_{-\infty}^\infty b(\xi) e^{j \xi \tau} d\tau }\) of \( b(\xi) \) at the locations \( \tau_n = 2t_n \), \( n=0,1,\dots,D-1 \), where the \( t_n \) are the locations at which \( q(t) \) is computed. The default (and currently only implemented) method for this type of spectrum is described in <a href="https://doi.org/10.1109/ECOC.2017.8346231">[Wahls 2017]</a>. It is currently REQUIRED that the time window is symmetric, T[0]=-T[1]. </p>

</div>
</div>
<a id="ga6a129a7c3e6a5da2690747dc228b76cf" name="ga6a129a7c3e6a5da2690747dc228b76cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a129a7c3e6a5da2690747dc228b76cf">&#9670;&#160;</a></span>fnft_nsev_inverse_dstype_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__data__types.html#ga6a129a7c3e6a5da2690747dc228b76cf">fnft_nsev_inverse_dstype_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum that specifies in which form the discrete spectrum is provided. Used in <a class="el" href="structfnft__nsev__inverse__opts__t.html">fnft_nsev_inverse_opts_t</a>.<br  />
 <br  />
 fnft_nsev_inverse_dstype_NORMING_CONSTANTS: The array normconsts_or_residues contains samples of \( b(\xi)\) for the values of bound_states provided as input to <a class="el" href="group__fnft__inverse.html#ga96e7f068533c27369ce71f94b4c31bd1">fnft_nsev_inverse</a>. <br  />
 <br  />
 fnft_nsev_inverse_dstype_RESIDUES: The array normconsts_or_residues contains samples of the of \( \frac{b(\xi)}{\partial{a(\xi)}/\partial{\xi}}\) for the values of bound_states provided as input to <a class="el" href="group__fnft__inverse.html#ga96e7f068533c27369ce71f94b4c31bd1">fnft_nsev_inverse</a>. <br  />
 <br  />
</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
